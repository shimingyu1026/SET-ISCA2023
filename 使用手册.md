# SET-ISCA2023 使用手册

## 项目简介

SET (Scheduling Space Exploration for Tiled Accelerators) 是一个用于深度神经网络加速器的层间调度空间探索框架,发表于 ISCA 2023。该框架能够系统性地探索不同的层间调度方案,优化AI模型在硬件加速器上的性能和能效。

### 主要功能

- 支持16种主流神经网络模型(ResNet、VGG、BERT、GPT等)
- 支持多种硬件配置(Polar、Eyeriss架构)
- 使用模拟退火(SA)算法进行调度优化
- 多种调度模式:Layer-Pipeline (LP)、Layer-Sequential (LS)、SET
- 生成详细的性能分析报告和IR文件

## 环境要求

### 系统要求
- macOS / Linux
- C++17 编译器 (GCC 或 Clang)
- xmake 构建工具 (>= 2.7.0)

### 依赖库
- pthread (系统自带)
- 数学库 (系统自带)

## 安装步骤

### 1. 安装 xmake

如果尚未安装 xmake,可以通过以下命令安装:

```bash
# macOS
brew install xmake

# Linux
curl -fsSL https://xmake.io/shget.text | bash
```

### 2. 克隆/下载项目

```bash
cd /Users/smy/Proj/SET-ISCA2023
```

### 3. 编译项目

```bash
# 编译 release 版本(推荐)
xmake build -m release

# 或编译 debug 版本
xmake build -m debug

# 或编译带调试信息的优化版本(用于性能分析)
xmake build -m releasedbg
```

编译成功后,可执行文件将生成在 `build/` 目录下,名为 `stschedule`。

### 4. 查看项目信息

```bash
# 查看项目详细信息
xmake info

# 清理构建文件
xmake clean

# 完全清理(包括配置)
xmake clean-all
```

## 使用方法

SET 支持两种输入方式:命令行参数输入和配置文件输入。

### 方式一:命令行参数输入

#### 基本语法

```bash
./build/stschedule --args <exp> <net> <batch> <core> <x> <y> <stride> <bw> <cost> <round> <gen_IR>
```

#### 参数说明

| 参数 | 说明 | 示例值 |
|------|------|--------|
| `exp` | 实验名称,用于输出文件命名(设为`None`则为空) | `bash_exp` |
| `net` | 神经网络名称(见下表) | `resnet` |
| `batch` | 批处理大小 | `64` |
| `core` | 核心架构类型 | `polar` 或 `eyeriss` |
| `x` | Mesh X轴长度 | `8` |
| `y` | Mesh Y轴长度 | `8` |
| `stride` | 初始放置步长(必须是x的约数) | `4` |
| `bw` | NoC带宽 (GB/s) | `24` |
| `cost` | 代价函数参数(见下表) | `1` |
| `round` | SA轮数系数(实际轮数=round×网络层数) | `10` |
| `gen_IR` | 是否生成IR文件 (0=否, 1=是) | `0` |

#### 支持的神经网络

| 网络标识 | 网络名称 | 说明 |
|---------|---------|------|
| `resnet` | ResNet-50 | 经典残差网络 |
| `resnet101` | ResNet-101 | 更深的残差网络 |
| `ires` | Inception-ResNet-v1 | Inception与ResNet结合 |
| `goog` | GoogLeNet | Google Inception网络 |
| `densenet` | DenseNet | 密集连接网络 |
| `darknet` | DarkNet-19 | YOLO检测网络 |
| `vgg` | VGG-19 | 经典深度卷积网络 |
| `zfnet` | ZFNet | 视觉识别网络 |
| `gnmt` | GNMT | Google神经机器翻译 |
| `lstm` | LSTM | 长短期记忆网络 |
| `trans` | Transformer | 完整Transformer |
| `trans_cell` | Transformer (单元) | Transformer单元 |
| `pnas` | PNASNet | 神经架构搜索网络 |
| `bert` | BERT-Large (单元) | BERT大模型单元 |
| `gpt_prefill` | GPT2-XL Prefill | GPT2预填充阶段 |
| `gpt_decode` | GPT2-XL Decode | GPT2解码阶段 |

> **注意**: 对于LLM模型(bert, gpt_prefill, gpt_decode),提供的是单元版本。如需运行完整网络,请查看 `src/nns/llm.cpp` 的注释。

#### 代价函数说明

代价函数用 $e$ (能耗)和 $d$ (延迟)表示:

| cost值 | 代价函数 | 说明 |
|--------|---------|------|
| `1` | $e \times d$ | EDP (Energy-Delay Product,默认) |
| `0` | $d$ | 仅优化延迟 |
| `-1` | $e$ | 仅优化能耗 |
| `n > 0` | $e^n \times d$ | 能耗权重更高 |
| `n < 0` | $e \times d^{-n}$ | 延迟权重更高 |

#### 运行示例

```bash
# 示例1: ResNet-50, batch=64, Polar架构, 8×8 mesh
./build/stschedule --args bash_exp resnet 64 polar 8 8 4 24 1 10 0

# 示例2: VGG-19, batch=32, Eyeriss架构, 优化延迟
./build/stschedule --args vgg_test vgg 32 eyeriss 8 8 4 24 0 10 0

# 示例3: BERT, batch=16, 生成IR文件
./build/stschedule --args bert_exp bert 16 polar 8 8 4 24 1 20 1
```

也可以使用提供的示例脚本:

```bash
bash ./bash_example.sh
```

### 方式二:配置文件输入

#### 基本语法

```bash
./build/stschedule <配置文件路径>
```

#### 配置文件格式

创建一个文本文件(如 `my_config.txt`),按以下格式填写参数:

```
exp experiment_name
net resnet
batch 64
core polar
x_len 8
y_len 8
stride 4
noc_bw 24
cost_func 1
round 10
IR 0
```

每行格式为: `参数名 参数值`

#### 参数对照表

| 配置文件参数名 | 对应命令行参数 | 说明 |
|--------------|--------------|------|
| `exp` | exp | 实验名称 |
| `net` | net | 网络名称 |
| `batch` | batch | 批处理大小 |
| `core` | core | 核心架构 |
| `x_len` | x | X轴长度 |
| `y_len` | y | Y轴长度 |
| `stride` | stride | 步长 |
| `noc_bw` | bw | NoC带宽 |
| `cost_func` | cost | 代价函数 |
| `round` | round | SA轮数系数 |
| `IR` | gen_IR | 生成IR |

#### 运行示例

```bash
# 使用配置文件运行
./build/stschedule my_config.txt

# 或使用提供的示例
bash ./file_example.sh
```

> **注意**: 项目中原本有 `file_in.txt` 示例文件,但目前未找到。你可以根据上述格式自行创建。

## 输出文件说明

运行完成后,SET会生成多个输出文件,文件名格式为: `{exp}_{type}_*.txt`

### 输出文件类型

| 文件名模式 | 内容说明 |
|-----------|---------|
| `{exp}_{type}_tree.txt` | RA树的纯树结构 |
| `{exp}_{type}_summary.txt` | 方案的性能代价摘要 |
| `{exp}_{type}_scheme.txt` | 完整方案信息(包括每个节点的cost/noc/dram/buffer等) |
| `{exp}_{type}_IR.json` | 生成的IR表示(如果gen_IR=1) |

### 搜索类型 (type)

SET 会执行多种搜索策略,每种策略生成一组输出文件:

| 搜索类型 | 说明 |
|---------|------|
| `init` | 初始RA树(作为SA的输入,不进行SA搜索) |
| `LP` | Layer-Pipeline模式(仅搜索LP模式的RA树) |
| `LS` | Layer-Sequential模式(仅搜索LS模式的RA树) |
| `SET` | 无约束SA搜索(可达所有有效RA树) |

### 示例输出文件

如果运行 `bash_example.sh`,将生成:

```
bash_exp_init_tree.txt
bash_exp_init_summary.txt
bash_exp_init_scheme.txt
bash_exp_LP_tree.txt
bash_exp_LP_summary.txt
bash_exp_LP_scheme.txt
bash_exp_LP_IR.json (如果gen_IR=1)
bash_exp_LS_tree.txt
bash_exp_LS_summary.txt
bash_exp_LS_scheme.txt
bash_exp_LS_IR.json (如果gen_IR=1)
bash_exp_SET_tree.txt
bash_exp_SET_summary.txt
bash_exp_SET_scheme.txt
bash_exp_SET_IR.json (如果gen_IR=1)
```

## 高级配置

### 硬件参数调整

如需调整更细致的硬件参数(如缓冲区大小、DRAM带宽、能耗模型等),需要修改 `src/main.cpp`:

#### 关键参数位置

```cpp
// 行 190-198: 其他硬件参数
Cluster::min_util = 0.75;          // 最小利用率
ofm_ubuf_vol = 10 KB;              // 输出特征图微缓冲区容量
double rel_dram_bw = 0.5;          // 相对DRAM带宽 (GB/s)/TOPS

// 行 197-198: NoC和DRAM能耗
NoC::DRAM_acc_cost = 7.5 * 8;      // DRAM访问能耗
NoC::hop_cost = 0.7 * 8;           // NoC单跳能耗

// 行 457-521: 核心架构详细配置
// 包括MAC数量、缓冲区大小、能耗参数等
```

#### Polar架构参数 (行461-492)

```cpp
PolarCore::PESetting pPE(8,8,0.018);  // PE设置
PolarCore::Bus pBus(4,4,0.018,16);    // 总线配置

// 缓冲区大小
pBuf.al1.Size = 8 KB;   // 激活L1
pBuf.ol1.Size = 2 KB;   // 输出L1
pBuf.wl1.Size = 4 KB;   // 权重L1
pBuf.ol2.Size = 28 KB;  // 输出L2
pBuf.ul3.Size = 1024 KB; // 统一L3

// 缓冲区能耗(读/写)
pBuf.al1.RCost = 0.0485625 * 8;
pBuf.al1.WCost = 0.0411625 * 8;
// ... 其他缓冲区类似
```

#### Eyeriss架构参数 (行493-517)

```cpp
EyerissCore::PESetting s2(32, 32, 0.018);
EyerissCore::Bus ibus(0.018, 64);

eBuf.al1.Size = 32;        // 激活L1
eBuf.pl1.Size = 1;         // 部分和L1
eBuf.wl1.Size = 128;       // 权重L1
eBuf.ul2.Size = 1024 KB;   // 统一L2
```

### 并发度调整

在 `src/main.cpp` 第58行:

```cpp
constexpr int tries = 4;  // SA并发线程数
```

增加 `tries` 可以提高搜索质量,但会增加运行时间。

### SA轮数调整

通过命令行参数 `round` 或配置文件 `round` 调整:

- 实际轮数 = `round` × 网络层数
- 建议值: 10-100
- 更大的值可能找到更优解,但运行时间更长

## 性能调优建议

### 1. 快速测试

```bash
# 使用较小的batch和较少的round
./build/stschedule --args quick_test resnet 8 polar 4 4 2 24 1 5 0
```

### 2. 高质量搜索

```bash
# 增加round和并发度(需修改tries)
./build/stschedule --args high_quality resnet 64 polar 8 8 4 24 1 100 1
```

### 3. 特定优化目标

```bash
# 优化延迟
./build/stschedule --args opt_delay resnet 64 polar 8 8 4 24 0 20 0

# 优化能耗
./build/stschedule --args opt_energy resnet 64 polar 8 8 4 24 -1 20 0
```

## 常见问题

### Q1: 编译失败

**问题**: `xmake build` 报错

**解决方案**:
```bash
# 确保xmake版本 >= 2.7.0
xmake --version

# 清理后重新配置
xmake clean-all
xmake config -m release
xmake build
```

### Q2: 缺少可执行文件

**问题**: `build/stschedule` 不存在

**解决方案**:
```bash
# 确认编译成功
xmake build -v

# 查找生成位置
find . -name stschedule
```

### Q3: 运行时参数错误

**问题**: `Should have 11 args!`

**解决方案**:
- 检查参数数量是否正确
- 如果编译时定义了 `NOT_GEN_IR`,参数数量为10而非11
- 使用配置文件方式避免参数遗漏

### Q4: 网络不存在

**问题**: `Network "xxx" not found!`

**解决方案**:
- 检查网络名称拼写
- 参考"支持的神经网络"表格
- 网络名称区分大小写(全部小写)

### Q5: stride参数错误

**问题**: 运行崩溃或结果异常

**解决方案**:
- 确保 `stride` 是 `x` 的约数
- 常用组合: x=8, stride=4 或 x=8, stride=2

### Q6: 内存不足

**问题**: 大型网络运行时内存溢出

**解决方案**:
- 减小batch size
- 减小mesh尺寸 (x, y)
- 减少round数
- 使用单线程(修改tries=1)

## 扩展开发

### 添加新的神经网络

1. 在 `src/nns/` 目录下添加网络定义
2. 在 `include/nns/nns.h` 中声明
3. 在 `src/main.cpp` 的 `All_Networks` map中注册

### 添加新的核心架构

1. 参考 `include/core.h` 定义新的Core类
2. 在 `src/main.cpp` 的 `init_core()` 函数中添加初始化逻辑

### 自定义调度算法

1. 参考 `src/sa.cpp` 实现新的搜索算法
2. 在 `src/main.cpp` 中调用新的搜索函数

详细的代码文档请参考 [`code_doc.md`](code_doc.md)。

## 构建系统说明

项目使用 xmake 构建系统,提供了以下优势:

- **多模式支持**: debug / release / releasedbg
- **自动依赖管理**: 自动链接pthread和math库
- **跨平台**: 支持macOS和Linux
- **并行编译**: 自动利用多核加速编译

### xmake常用命令

```bash
# 配置项目
xmake config -m release         # 配置为release模式
xmake config -m debug           # 配置为debug模式

# 构建
xmake build                     # 构建项目
xmake build -v                  # 详细输出
xmake rebuild                   # 重新构建

# 清理
xmake clean                     # 清理编译产物
xmake clean-all                 # 完全清理

# 查看信息
xmake info                      # 查看项目信息
xmake show -l targets           # 列出所有目标
```

## 参考文献

如果在学术研究中使用此工具,请引用:

```bibtex
@inproceedings{10.1145/3579371.3589048,
  author = {Cai, Jingwei and Wei, Yuchen and Wu, Zuotong and Peng, Sen and Ma, Kaisheng},
  title = {Inter-layer Scheduling Space Definition and Exploration for Tiled Accelerators},
  booktitle = {Proceedings of the 50th Annual International Symposium on Computer Architecture},
  year = {2023},
  series = {ISCA '23}
}
```

## 联系方式

如有问题、Bug报告或建议,请:

- 在GitHub仓库提交Issue
- 发送邮件至: 1148821791@qq.com 或 weiyc22@mails.tsinghua.edu.cn

## 相关项目

- [GEMINI-HPCA2024](https://github.com/SET-Scheduling-Project/GEMINI-HPCA2024): 基于SET开发的大规模DNN Chiplet加速器架构协同探索框架
- [Tile-Alloc-Algorithm](https://github.com/SET-ISCA2023/Tile-Alloc-Algorithm): 论文中提到的调度空间计算和最优硬件瓦片分配算法

---

**版本**: 1.0.0  
**更新日期**: 2025-12-27  
**构建系统**: xmake 2.7.0+
